<!DOCTYPE html>
<html>
<head>
    <title>Impostor Game</title>
    <style>
        button { margin: 5px; }
        #topRight { position: fixed; top: 10px; right: 10px; }
    </style>
</head>
<body>

<div id="topRight"></div>
<div id="timer" style="text-align:center;font-size:24px;display:none"></div>

<h2 id="title">Waiting for host...</h2>

<div id="hostLogin">
    <input id="hostPass" type="password" placeholder="Host password">
    <button onclick="hostLogin()">Login as Host</button>
</div>

<div id="joinArea" style="display:none">
    <input id="name" placeholder="Your name">
    <button onclick="join()">Join</button>
</div>

<ul id="players"></ul>

<div id="votingArea" style="display:none">
    <h3>Vote for the impostor</h3>
    <div id="voteList"></div>
    <p id="remainingVotes"></p>
</div>

<button id="revealBtn" style="display:none" onclick="revealResults()">
    Reveal Results
</button>

<div id="leaderboardArea" style="display:none">
    <table id="leaderboardTable" style="border-collapse:collapse;width:100%">
        <tr style="border-bottom:1px solid #ccc">
            <th style="padding:10px;text-align:left">Rank</th>
            <th style="padding:10px;text-align:left">Player</th>
            <th style="padding:10px;text-align:right">Score</th>
        </tr>
    </table>
</div>

<button id="nextRoundBtn" style="display:none" onclick="nextRound()">
    Next Round
</button>

<div id="roundSettings" style="display:none">
    <label>
        Round length:
        <span id="roundLengthDisplay">3:00</span>
    </label>
    <div style="display:inline-block;margin-left:10px">
        <button id="decreaseDefault30">-30s</button>
        <button id="increaseDefault30">+30s</button>
    </div>
</div>

<button id="startGame" style="display:none" onclick="startGame()">Start Game</button>

<div id="playerManagement" style="display:none">
    <ul id="playerManagementList">
        <li>Manage me b</li>
    </ul>
</div>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
    let lastPlayers = [];
    let myVote = null;
    let lastState = null;
    let currentState = null;
    let showingResults = false;  // Track if results are being displayed

    const BACKEND_URL = location.hostname === "localhost"
        ? "http://localhost:5001"
        : "https://imposter-backend-ch3h.onrender.com";

    let hostToken = localStorage.getItem("hostToken");
    // Respect a suppress flag so "Leave" can prevent immediate auto-rejoin on reload
    let suppressAutoJoin = localStorage.getItem("suppressAutoJoin");
    let storedPlayerId = localStorage.getItem("playerId");
    let playerId = storedPlayerId;
    
    // Build query params conditionally
    let query = { token: hostToken };
    if (!suppressAutoJoin && storedPlayerId) {
        query.playerId = storedPlayerId;
    }
    if (suppressAutoJoin) {
        // Clear the flag so next full reload will allow auto-join
        localStorage.removeItem("suppressAutoJoin");
    }

    const socket = io(BACKEND_URL, {
        query: query
    });

    let isHost = false;
    let hasJoined = false;

    socket.on("identity_update", data => {
        if (data.playerId) {
            playerId = data.playerId;
            localStorage.setItem("playerId", data.playerId);
        }

        isHost = data.isHost;
        hasJoined = data.hasJoined;

        if (hasJoined) {
            document.getElementById("joinArea").style.display = "none";
        }
        socket.emit("request_state_sync");
    });

    function renderPlayers(players) {
        // Ensure host's playerId is always available immediately after joining
        playerId = localStorage.getItem("playerId") || playerId;
        const ul = document.getElementById("players");
        ul.innerHTML = "";
        players.forEach(p => {
            const li = document.createElement("li");
            li.textContent = p.name;
            ul.appendChild(li);
        });

        // Host-only player management list
        const manageList = document.getElementById("playerManagementList");
        manageList.innerHTML = "";

        if (!isHost) return;

        players.forEach(p => {
            // Host should not be able to remove themselves
            if (String(p.player_id) === String(playerId)) return;

            const li = document.createElement("li");
            li.style.marginBottom = "6px";

            const nameSpan = document.createElement("span");
            nameSpan.textContent = p.name;
            nameSpan.style.marginRight = "10px";

            const btn = document.createElement("button");
            btn.textContent = "Remove";
            btn.onclick = () => {
                kickPlayer(p.player_id, p.name);
            };

            li.appendChild(nameSpan);
            li.appendChild(btn);
            manageList.appendChild(li);
        });
    }

    function renderVoting(players) {
        const list = document.getElementById("voteList");
        list.innerHTML = "";

        // Always get playerId from localStorage (most reliable source)
        playerId = localStorage.getItem("playerId") || playerId;
        
        if (!playerId) {
            console.warn("renderVoting: No playerId available!");
            return;
        }

        console.log("renderVoting: filtering out playerId=", playerId);

        players.forEach(p => {
            // Strict string comparison to filter out current player
            if (String(p.player_id) === String(playerId)) {
                console.log("Filtering out player:", p.name, p.player_id);
                return;
            }

            const label = document.createElement("label");
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = "vote";
            radio.value = p.player_id;

            if (myVote === p.player_id) {
                radio.checked = true;
            }

            radio.onchange = () => {
                myVote = p.player_id;
                socket.emit("cast_vote", { voted: p.player_id });
            };

            label.appendChild(radio);
            label.appendChild(document.createTextNode(" " + p.name));
            list.appendChild(label);
            list.appendChild(document.createElement("br"));
        });
    }

    function hostLogin() {
        socket.emit("host_login", { password: document.getElementById("hostPass").value });
    }

    function join() {
        if (hasJoined) {
            // is this called if they have joined before, and we are merging the data
            return;
        }

        const name = document.getElementById("name").value.trim();
        if (!name) return;

        // Check if name already exists
        if (lastPlayers.some(p => p.name.toLowerCase() === name.toLowerCase())) {
            alert("This name is already taken!");
            return;
        }

        // Send the stored playerId (if any) so rejoining merges with previous data
        const pidToSend = localStorage.getItem("playerId");
        socket.emit("join", { name, playerId: pidToSend });
    }

    function leave() {
        if (currentState === "voting") {
            alert("Cannot leave during voting. Wait for results.");
            return;
        }
        
        if (!confirm("Are you sure you want to leave?")) {
            return;
        }
    
        // Keep playerId in localStorage so they can rejoin and merge scores
        // Only remove hostToken and set a flag to suppress auto-rejoin on reload
        localStorage.removeItem("hostToken");
        localStorage.setItem("suppressAutoJoin", "1");
        hasJoined = false;
        socket.emit("leave");
    }

    function kickPlayer(playerId, playerName) {
        if (currentState === "voting") {
            alert("Cannot remove players during voting.");
            return;
        }

        if (!confirm(`Remove ${playerName} from the game?`)) {
            return;
        }

        socket.emit("leave", { playerId });
    }

    const MIN_PLAYERS = 3;
    function startGame() {
        if (!hasJoined) {
            alert("Host must join the game first");
            return;
        }
        // lastPlayers contains only active players
        if (lastPlayers.length < MIN_PLAYERS) {
            alert(`Need at least ${MIN_PLAYERS} players to start the game.`);
            return;
        }
        socket.emit("start_game");
    }

    function updateMinutes() {
        const mins = parseInt(document.getElementById("roundMinutes")?.value || 3);
        socket.emit("set_round_minutes", { minutes: mins });
    }

    function setRoundSeconds(seconds) {
        socket.emit("set_round_seconds", { seconds });
    }

    function adjustGameTime(deltaSec) {
        socket.emit("adjust_time", { delta: deltaSec });
    }

    function togglePause() {
        socket.emit("toggle_pause");
    }

    function revealResults() {
        socket.emit("reveal_results");
    }

    function nextRound() {
        socket.emit("next_round");
    }

    function confirmEndSession() {
        if (confirm("End the session? Everyone will be sad!")) {
            socket.emit("end_session");
        }
    }

    socket.on("host_login_result", data => {
        if (!data.success) return alert("Host login failed");

        localStorage.setItem("hostToken", data.token);
        location.reload();
    });

    socket.on("join_result", data => {
        if (!data.success) return;

        hasJoined = true;
        localStorage.setItem("playerId", data.playerId);

        document.getElementById("name").value = "";
        document.getElementById("joinArea").style.display = "none";
        // Only update topRight to show Leave button if NOT host
        if (!isHost) {
            const top = document.getElementById("topRight");
            top.innerHTML = "<button onclick='leave()'>Leave</button>";
        }

        // Host re-joining after reset must re-show Start Game
        if (isHost) {
            document.getElementById("startGame").style.display = "block";
        }

        socket.emit("request_state_sync");
    });

    socket.on("state_update", data => {
        currentState = data.state;

        if (!data.hostExists) {
            localStorage.removeItem("playerId");
            localStorage.removeItem("hostToken");
            hasJoined = false;
            showingResults = false;
            // Clear players list
            document.getElementById("players").innerHTML = "";
            // Hide start game button
            document.getElementById("startGame").style.display = "none";
            // Clear topRight explicitly when no host exists
            document.getElementById("topRight").innerHTML = "";
        }

        // Don't override display if showing results
        if (showingResults) {
            return;
        }

        const hostLogin = document.getElementById("hostLogin");
        const joinArea = document.getElementById("joinArea");
        const startBtn = document.getElementById("startGame");
        const title = document.getElementById("title");
        const top = document.getElementById("topRight");
        const timer = document.getElementById("timer");
        const roundBox = document.getElementById("roundSettings");
        const playerManage = document.getElementById("playerManagement");

        title.textContent =
            data.state === "waiting" ? "Waiting for host..." :
            data.state === "lobby" ? "Lobby" :
            data.state === "game" ? "Game Started" :
            data.state === "voting" ? "Vote" :
            data.state === "leaderboard" ? "Leaderboard" :
            "Vote";

        // Host login
        hostLogin.style.display =
            data.hostExists ? "none" : "block";

        // Name entry:
        // - visible for ALL clients once host exists
        // - hidden after that client has joined
        if (data.hostExists && !hasJoined) {
            joinArea.style.display = "block";
        } else {
            joinArea.style.display = "none";
        }

        // Update round length display (seconds)
        const roundLen = data.roundLengthSeconds !== undefined ? data.roundLengthSeconds : (data.roundMinutes ? data.roundMinutes * 60 : 180);
        const mins = Math.floor(roundLen / 60);
        const secs = String(roundLen % 60).padStart(2, '0');
        document.getElementById("roundLengthDisplay").textContent = `${mins}:${secs}`;

        roundBox.style.display =
            (isHost && hasJoined && (data.state === "lobby" || data.state === "leaderboard")) ? "block" : "none";

        playerManage.style.display = isHost ? "block" : "none";

        startBtn.style.display =
            (isHost && hasJoined && data.state === "lobby") ? "block" : "none";

        // Top-right controls
        if (data.hostExists) {
            top.innerHTML = "";
            if (isHost) {
                top.innerHTML = "<b>Host</b> <button onclick='confirmEndSession()'>End Session</button>";
                // Add game controls only during game state
                if (data.state === "game") {
                    const controls = document.createElement('div');
                    controls.style.display = 'inline-block';
                    controls.style.marginLeft = '10px';
                    controls.innerHTML = '<button id="decrease30">-30s</button> <button id="pauseBtn">Pause</button> <button id="increase30">+30s</button>';
                    top.appendChild(controls);
                    document.getElementById('decrease30').onclick = () => adjustGameTime(-30);
                    document.getElementById('increase30').onclick = () => adjustGameTime(30);
                    document.getElementById('pauseBtn').onclick = () => togglePause();
                }
            } else if (hasJoined) {
                if (data.state === "leaderboard") {
                    if (!data.canContinue) {
                        top.innerHTML = "<button onclick='leave()'>Return to Lobby</button>";
                    } else {
                        top.innerHTML = "<button onclick='leave()'>Leave</button>";
                    }
                } else {
                    top.innerHTML = "<button onclick='leave()'>Leave</button>";
                }
            }
        }

        if (data.state === "game") {
            timer.style.display = "block";
            if (data.timeRemaining !== null && data.timeRemaining !== undefined) {
                const mins = Math.floor(data.timeRemaining / 60);
                const secs = String(data.timeRemaining % 60).padStart(2, "0");
                timer.textContent = `${mins}:${secs}`;
            }
            // Update pause button text if present
            const pauseBtn = document.getElementById("pauseBtn");
            if (pauseBtn) {
                pauseBtn.textContent = data.timerPaused ? "Play" : "Pause";
            }
        } else {
            timer.style.display = "none";
        }

        const votingArea = document.getElementById("votingArea");
        const remaining = document.getElementById("remainingVotes");
        const playersList = document.getElementById("players");
        const leaderboardArea = document.getElementById("leaderboardArea");
        const nextRoundBtn = document.getElementById("nextRoundBtn");
        const revealBtn = document.getElementById("revealBtn");

        // If player left mid-game/voting, show rejoin area instead of voting UI
        if (!hasJoined && (data.state === "game" || data.state === "voting")) {
            votingArea.style.display = "none";
            playersList.style.display = "block";
            leaderboardArea.style.display = "none";
            joinArea.style.display = "block";
        } else if (data.state === "leaderboard") {
            leaderboardArea.style.display = "block";
            votingArea.style.display = "none";
            playersList.style.display = "none";
            revealBtn.style.display = "none";
            document.getElementById("startGame").style.display = "none";
            
            // Populate leaderboard table if data provided
            if (data.leaderboard && data.leaderboard.length > 0) {
                const leaderboardTable = document.getElementById("leaderboardTable");
                const rows = leaderboardTable.querySelectorAll("tr");
                rows.forEach((row, idx) => {
                    if (idx > 0) row.remove();
                });
                
                data.leaderboard.forEach((player, idx) => {
                    const tr = document.createElement("tr");
                    tr.style.borderBottom = "1px solid #ccc";
                    
                    const rankTd = document.createElement("td");
                    rankTd.textContent = idx + 1;
                    rankTd.style.padding = "10px";
                    
                    const nameTd = document.createElement("td");
                    nameTd.textContent = player.name;
                    nameTd.style.padding = "10px";
                    
                    const scoreTd = document.createElement("td");
                    scoreTd.textContent = player.score;
                    scoreTd.style.padding = "10px";
                    scoreTd.style.textAlign = "right";
                    
                    tr.appendChild(rankTd);
                    tr.appendChild(nameTd);
                    tr.appendChild(scoreTd);
                    leaderboardTable.appendChild(tr);
                });
            }
            
            if (isHost) {
                nextRoundBtn.style.display = "block";
            }
        } else if (data.state === "voting") {
            if (currentState !== "voting") {
                myVote = null;
            }

            votingArea.style.display = "block";
            playersList.style.display = "none";
            leaderboardArea.style.display = "none";
            nextRoundBtn.style.display = "none";

            remaining.textContent =
                data.remainingVotes > 0
                ? `Waiting for ${data.remainingVotes} players to vote...`
                : "All votes are in. Waiting for host.";

            // Render voting list - ensure it renders when state transitions to voting
            if (lastPlayers.length > 0) {
                renderVoting(lastPlayers);
            } else if (!playerId) {
                // If playerId not yet set, request state sync to get it
                socket.emit("request_state_sync");
            }
        } else {
            votingArea.style.display = "none";
            playersList.style.display = "block";
            leaderboardArea.style.display = "none";
            nextRoundBtn.style.display = "none";
        }

        if (data.state === "voting" && isHost && data.remainingVotes === 0) {
            revealBtn.style.display = "block";
        } else {
            revealBtn.style.display = "none";
        }
    });

    socket.on("players_update", data => {
        lastPlayers = data.players;
        renderPlayers(data.players);

        // Always re-render voting list when players update during voting
        if (currentState === "voting" && playerId) {
            renderVoting(lastPlayers);
        }
    });

    // default round length +/- buttons (in lobby/leaderboard)
    document.getElementById('decreaseDefault30').onclick = () => {
        const currentLen = parseInt(document.getElementById("roundLengthDisplay").textContent.split(':')[0]) * 60 
                         + parseInt(document.getElementById("roundLengthDisplay").textContent.split(':')[1]);
        const newLen = Math.max(60, Math.min(5 * 60, currentLen - 30));
        socket.emit('set_round_seconds', { seconds: newLen });
    };

    document.getElementById('increaseDefault30').onclick = () => {
        const currentLen = parseInt(document.getElementById("roundLengthDisplay").textContent.split(':')[0]) * 60 
                         + parseInt(document.getElementById("roundLengthDisplay").textContent.split(':')[1]);
        const newLen = Math.max(60, Math.min(5 * 60, currentLen + 30));
        socket.emit('set_round_seconds', { seconds: newLen });
    };

    socket.on("role", data => {
        if (data.role === "impostor") {
            alert("You are the IMPOSTOR");
        } else {
            alert(`The word is: ${data.word}`);
        }
    });

    socket.on("round_result", data => {
        const impostorName = data.impostor;
        const votedOutName = data.votedOut;
        const myVoted = myVote;
        const leaderboard = data.leaderboard || [];
        
        // Find the IDs by looking up names in lastPlayers
        const impostorPlayer = lastPlayers.find(p => p.name === impostorName);
        const impostorId = impostorPlayer ? impostorPlayer.player_id : null;
        
        const votedOutPlayer = lastPlayers.find(p => p.name === votedOutName);
        const votedOutId = votedOutPlayer ? votedOutPlayer.player_id : null;
        
        // Find the name of who I voted for
        const myVotedPlayer = lastPlayers.find(p => p.player_id === myVoted);
        const myVotedName = myVotedPlayer ? myVotedPlayer.name : "Unknown";

        console.log("Round result debug:", {
            myVoted,
            myVotedName,
            impostorId,
            impostorName,
            votedOutId,
            votedOutName,
            match: myVoted === impostorId
        });

        // Use backend-provided counts for impostor messaging
        const numCorrect = data.numCorrect !== undefined ? data.numCorrect : 0;
        const numPossible = data.numPossible !== undefined ? data.numPossible : Math.max(0, lastPlayers.length - 1);
        const isImpostor = String(playerId) === String(impostorId);
        const didVoteCorrect = String(myVoted) === String(impostorId);

        if (isImpostor) {
            alert(`${numCorrect}/${numPossible} players correctly guessed you.`);
        } else if (!myVoted) {
            alert(`You didn't vote.\nImpostor was ${impostorName}.`);
        } else if (didVoteCorrect) {
            alert(`Correct! You voted for ${myVotedName}, who was the impostor.`);
        } else {
            alert(`Wrong! You voted for ${myVotedName}.\nThe impostor was ${impostorName}.`);
        }

        // Display leaderboard
        const leaderboardTable = document.getElementById("leaderboardTable");
        const rows = leaderboardTable.querySelectorAll("tr");
        rows.forEach((row, idx) => {
            if (idx > 0) row.remove(); // Remove old rows
        });

        leaderboard.forEach((player, idx) => {
            const tr = document.createElement("tr");
            tr.style.borderBottom = "1px solid #ccc";
            
            const rankTd = document.createElement("td");
            rankTd.textContent = idx + 1;
            rankTd.style.padding = "10px";
            
            const nameTd = document.createElement("td");
            nameTd.textContent = player.name;
            nameTd.style.padding = "10px";
            
            const scoreTd = document.createElement("td");
            scoreTd.textContent = player.score;
            scoreTd.style.padding = "10px";
            scoreTd.style.textAlign = "right";
            
            tr.appendChild(rankTd);
            tr.appendChild(nameTd);
            tr.appendChild(scoreTd);
            leaderboardTable.appendChild(tr);
        });

        myVote = null;
    });

    socket.on("next_round_started", data => {
        // Reset the results flag when new round starts
        showingResults = false;
    });

    socket.on("leave_success", data => {
        if (data?.kicked) {
            // ðŸ”‘ Prevent auto-rejoin ONLY on the kicked client
            localStorage.setItem("suppressAutoJoin", "1");
        }

        hasJoined = false;
        alert(data?.kicked ? "You were removed from the game." : "You have left successfully");
        location.reload();
    });

    socket.on("player_joined", data => {
        alert(`${data.name} has joined`);
    });

    socket.on("impostor_left", data => {
        if (!hasJoined) return;

        if (data.kicked) {
            alert(`${data.name} was REMOVED by the host.\n\nThey were the IMPOSTOR.\nGame returned to lobby.`);
        } else {
            alert(`${data.name} left the game.\n\nThey were the IMPOSTOR.\nGame returned to lobby.`);
        }
    });

    socket.on("non_impostor_left", data => {
        if (!hasJoined) return;

        if (data.kicked) {
            alert(`${data.name} was removed by the host.`);
        } else {
            alert(`${data.name} left. They weren't the impostor.`);
        }
    });

    socket.on("player_left", data => {
        if (!hasJoined) return;

        if (data.kicked) {
            alert(`${data.name} was removed by the host.`);
        } else {
            alert(`${data.name} has left.`);
        }
    });

    socket.on("host_powerful", data => {
        if (isHost) {
            alert(`You can't kick yourself out!`);
        }
    });

    socket.on("game_ended", data => {
        if (!hasJoined) return;
        const reason = data && data.reason ? data.reason : "Game ended.";
        alert(reason);
        // request state sync to show lobby
        socket.emit("request_state_sync");
    });
</script>
</body>
</html>